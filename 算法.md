# 算法

## 竞赛技巧

```c++
#include <bits/stdc++.h>  // 万能头文件，包含所有STL（某些OJ可能不支持）
using namespace std;

/* ========== 1. 常用类型定义和宏 ========== */
#define ll long long
#define ull unsigned long long
#define ld long double
#define pii pair<int, int>
#define pll pair<ll, ll>
#define vi vector<int>
#define vll vector<ll>
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define fi first
#define se second
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((int)(x).size())
#define rep(i, a, b) for(int i = (a); i <= (b); i++)
#define per(i, a, b) for(int i = (a); i >= (b); i--)

// 防溢出宏（谨慎使用，可能导致MLE）
// #define int long long

/* ========== 2. 常用常量 ========== */
const int INF = 0x3f3f3f3f;              // int最大值近似（约2.1e9）
const ll LINF = 0x3f3f3f3f3f3f3f3f;      // long long最大值近似
const int MOD = 1e9 + 7;                  // 常用模数
const int MOD2 = 998244353;               // 另一个常用模数
const double EPS = 1e-9;                  // 浮点数精度
const double PI = acos(-1);               // 圆周率
const int MAXN = 2e5 + 5;                 // 常用数组大小

/* ========== 3. 输入输出优化 ========== */
void fast_io() {
    ios::sync_with_stdio(false);  // 关闭C++与C的同步
    cin.tie(nullptr);             // 解除cin与cout的绑定
    cout.tie(nullptr);            // 解除cout的绑定
}

/* ========== 4. 调试宏（重要！） ========== */
#ifdef LOCAL
#define debug(x) cerr << #x << " = " << x << endl
#define debugv(x) cerr << #x << " = "; for(auto i : x) cerr << i << " "; cerr << endl
#define debugp(x) cerr << #x << " = (" << x.fi << ", " << x.se << ")" << endl
#else
#define debug(x)
#define debugv(x)
#define debugp(x)
#endif

/* ========== 5. signed main() 的使用 ========== */
/*
为什么使用 signed main() 而不是 int main()？

1. 兼容性考虑：
   当使用 #define int long long 宏时：
   - int main() 会被替换成 long long main()，这是非法的
   - signed main() 不受影响，等价于 signed int main()

2. 竞赛习惯：
   - 很多竞赛选手的模板都使用 signed main()
   - 从其他模板复制代码时保持一致性

3. 实际使用：
   - 如果没有 #define int long long，用 int main() 完全可以
   - signed main() 是更安全的选择
*/

/* ========== 6. 位运算技巧 ========== */
namespace BitTricks {
    // 判断奇偶
    bool isOdd(int x) { return x & 1; }
    
    // 快速乘除2的幂
    int mul2pow(int x, int k) { return x << k; }  // x * 2^k
    int div2pow(int x, int k) { return x >> k; }  // x / 2^k
    
    // 判断是否为2的幂
    bool isPowerOf2(int x) { return (x > 0) && ((x & (x - 1)) == 0); }
    
    // 获取最低位的1（lowbit）
    int lowbit(int x) { return x & (-x); }
    
    // 统计1的个数
    int popcount(int x) { return __builtin_popcount(x); }
    int popcountll(ll x) { return __builtin_popcountll(x); }
    
    // 前导零个数
    int clz(int x) { return __builtin_clz(x); }
    
    // 交换两数（不用额外变量）
    void swap_xor(int &a, int &b) { a ^= b; b ^= a; a ^= b; }
    
    // 取绝对值
    int abs_bit(int x) { return (x ^ (x >> 31)) - (x >> 31); }
}

/* ========== 7. 数学相关 ========== */
namespace Math {
    // 快速幂
    ll qpow(ll a, ll b, ll mod = MOD) {
        ll res = 1;
        a %= mod;
        while(b > 0) {
            if(b & 1) res = res * a % mod;
            a = a * a % mod;
            b >>= 1;
        }
        return res;
    }
    
    // 最大公约数
    ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
    
    // 最小公倍数
    ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }
    
    // 扩展欧几里得算法
    ll exgcd(ll a, ll b, ll &x, ll &y) {
        if(!b) { x = 1, y = 0; return a; }
        ll d = exgcd(b, a % b, y, x);
        y -= a / b * x;
        return d;
    }
    
    // 乘法逆元（费马小定理）
    ll inv(ll a, ll mod = MOD) { return qpow(a, mod - 2, mod); }
    
    // 判断质数
    bool isPrime(ll n) {
        if(n < 2) return false;
        if(n == 2) return true;
        if(n % 2 == 0) return false;
        for(ll i = 3; i * i <= n; i += 2) {
            if(n % i == 0) return false;
        }
        return true;
    }
    
    // 组合数计算（小范围）
    vector<vector<ll>> getComb(int n) {
        vector<vector<ll>> C(n + 1, vector<ll>(n + 1, 0));
        for(int i = 0; i <= n; i++) {
            C[i][0] = C[i][i] = 1;
            for(int j = 1; j < i; j++) {
                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
            }
        }
        return C;
    }
}

/* ========== 8. 字符串处理 ========== */
namespace StringUtils {
    // 字符串转数字
    int toInt(const string& s) { return stoi(s); }
    ll toLong(const string& s) { return stoll(s); }
    double toDouble(const string& s) { return stod(s); }
    
    // 数字转字符串
    string toString(ll x) { return to_string(x); }
    
    // 字符串分割
    vector<string> split(const string& s, char delimiter) {
        vector<string> tokens;
        stringstream ss(s);
        string token;
        while(getline(ss, token, delimiter)) {
            tokens.pb(token);
        }
        return tokens;
    }
    
    // 判断回文
    bool isPalindrome(const string& s) {
        int l = 0, r = sz(s) - 1;
        while(l < r) {
            if(s[l] != s[r]) return false;
            l++, r--;
        }
        return true;
    }
    
    // 字符串哈希（单哈希）
    const int BASE = 131;
    vector<ull> getHash(const string& s) {
        int n = sz(s);
        vector<ull> h(n + 1, 0), p(n + 1, 1);
        for(int i = 0; i < n; i++) {
            h[i + 1] = h[i] * BASE + s[i];
            p[i + 1] = p[i] * BASE;
        }
        return h;
    }
}

/* ========== 9. STL使用技巧 ========== */
namespace STLTricks {
    void vectorTricks() {
        vi v = {3, 1, 4, 1, 5, 9, 2, 6};
        
        // 排序和去重
        sort(all(v));
        v.erase(unique(all(v)), v.end());
        
        // 逆序
        reverse(all(v));
        
        // 旋转（循环移位）
        rotate(v.begin(), v.begin() + 2, v.end());
        
        // 二分查找
        int pos1 = lower_bound(all(v), 5) - v.begin();  // 第一个>=5的位置
        int pos2 = upper_bound(all(v), 5) - v.begin();  // 第一个>5的位置
        
        // 第k小元素
        nth_element(v.begin(), v.begin() + 2, v.end());  // v[2]是第3小的
    }
    
    void mapTricks() {
        map<int, int> cnt;
        vi v = {1, 2, 2, 3, 3, 3};
        
        // 计数
        for(int x : v) cnt[x]++;
        
        // 检查键是否存在
        if(cnt.count(2)) { /* 存在 */ }
        if(cnt.find(2) != cnt.end()) { /* 存在 */ }
    }
    
    void setTricks() {
        set<int> s = {3, 1, 4, 1, 5};  // 自动去重排序
        
        // 查找
        auto it = s.find(3);
        if(it != s.end()) { /* 找到了 */ }
        
        // 删除
        s.erase(3);  // 删除值为3的元素
        s.erase(s.begin());  // 删除第一个元素
    }
    
    void priorityQueueTricks() {
        priority_queue<int> maxHeap;  // 大根堆
        priority_queue<int, vi, greater<int>> minHeap;  // 小根堆
        
        // 自定义比较
        priority_queue<pii, vector<pii>, function<bool(pii, pii)>> 
            pq([](pii a, pii b) { return a.fi + a.se > b.fi + b.se; });
    }
}

/* ========== 10. 常用算法模板 ========== */
namespace Algorithms {
    // 前缀和
    vector<ll> getPrefixSum(const vi& a) {
        int n = sz(a);
        vector<ll> prefix(n + 1, 0);
        for(int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + a[i];
        }
        return prefix;
        // 区间[l, r]的和 = prefix[r + 1] - prefix[l]
    }
    
    // 差分数组
    vi getDifference(const vi& a) {
        int n = sz(a);
        vi diff(n + 1, 0);
        for(int i = 0; i < n; i++) {
            diff[i] = a[i] - (i > 0 ? a[i-1] : 0);
        }
        return diff;
        // 区间[l, r]加x: diff[l] += x, diff[r+1] -= x
    }
    
    // 二分查找模板
    int lowerBound(const vi& arr, int target) {
        int l = 0, r = sz(arr);
        while(l < r) {
            int mid = l + (r - l) / 2;
            if(arr[mid] >= target) r = mid;
            else l = mid + 1;
        }
        return l;
    }
    
    int upperBound(const vi& arr, int target) {
        int l = -1, r = sz(arr) - 1;
        while(l < r) {
            int mid = l + (r - l + 1) / 2;
            if(arr[mid] <= target) l = mid;
            else r = mid - 1;
        }
        return l;
    }
    
    // 离散化
    vi discretize(vi& a) {
        vi b = a;
        sort(all(b));
        b.erase(unique(all(b)), b.end());
        for(int& x : a) {
            x = lower_bound(all(b), x) - b.begin();
        }
        return b;  // 返回离散化后的映射表
    }
    
    // LIS（最长递增子序列）
    int getLIS(const vi& a) {
        vi dp;
        for(int x : a) {
            auto it = lower_bound(all(dp), x);
            if(it == dp.end()) dp.pb(x);
            else *it = x;
        }
        return sz(dp);
    }
}

/* ========== 11. 输入输出技巧 ========== */
namespace IO {
    // 读入不定数量的数据
    vi readUntilEOF() {
        vi data;
        int x;
        while(cin >> x) data.pb(x);
        return data;
    }
    
    // 读入一整行
    string readLine() {
        string line;
        getline(cin, line);
        return line;
    }
    
    // 快速输出（避免endl）
    void fastPrint(const vi& a) {
        for(int i = 0; i < sz(a); i++) {
            cout << a[i];
            if(i < sz(a) - 1) cout << ' ';
        }
        cout << '\n';  // 比endl快
    }
}

/* ========== 12. 计数排序/桶排序 ========== */
namespace CountingSort {
    // 基础计数排序
    void countingSort(vi& arr, int maxVal) {
        vi cnt(maxVal + 1, 0);
        for(int x : arr) cnt[x]++;
        
        int idx = 0;
        for(int i = 0; i <= maxVal; i++) {
            while(cnt[i]-- > 0) {
                arr[idx++] = i;
            }
        }
    }
    
    // 选票排序问题
    void voteSort() {
        int n, m;
        cin >> n >> m;
        
        vi cnt(n + 1, 0);
        for(int i = 0; i < m; i++) {
            int vote;
            cin >> vote;
            cnt[vote]++;
        }
        
        for(int i = 1; i <= n; i++) {
            for(int j = 0; j < cnt[i]; j++) {
                cout << i << ' ';
            }
        }
    }
}

/* ========== 13. 常用数据结构 ========== */
namespace DataStructures {
    // 并查集
    struct UnionFind {
        vi parent, rank;
        int n;
        
        UnionFind(int _n) : n(_n) {
            parent.resize(n);
            rank.resize(n, 0);
            iota(all(parent), 0);
        }
        
        int find(int x) {
            return parent[x] == x ? x : parent[x] = find(parent[x]);
        }
        
        bool unite(int x, int y) {
            int px = find(x), py = find(y);
            if(px == py) return false;
            if(rank[px] < rank[py]) swap(px, py);
            parent[py] = px;
            if(rank[px] == rank[py]) rank[px]++;
            return true;
        }
        
        bool same(int x, int y) { return find(x) == find(y); }
    };
    
    // 线段树（区间求和）
    struct SegmentTree {
        vi tree;
        int n;
        
        SegmentTree(const vi& arr) {
            n = sz(arr);
            tree.resize(4 * n);
            build(arr, 1, 0, n - 1);
        }
        
        void build(const vi& arr, int node, int start, int end) {
            if(start == end) {
                tree[node] = arr[start];
            } else {
                int mid = (start + end) / 2;
                build(arr, 2 * node, start, mid);
                build(arr, 2 * node + 1, mid + 1, end);
                tree[node] = tree[2 * node] + tree[2 * node + 1];
            }
        }
        
        int query(int node, int start, int end, int l, int r) {
            if(r < start || end < l) return 0;
            if(l <= start && end <= r) return tree[node];
            int mid = (start + end) / 2;
            return query(2 * node, start, mid, l, r) + 
                   query(2 * node + 1, mid + 1, end, l, r);
        }
        
        int query(int l, int r) { return query(1, 0, n - 1, l, r); }
    };
}

/* ========== 14. 时间复杂度估算 ========== */
/*
常见时间复杂度对应的数据规模：
- O(1): 任意
- O(log n): 任意
- O(n): 10^8
- O(n log n): 10^6
- O(n²): 10^4
- O(n³): 500
- O(2^n): 20
- O(n!): 10

1秒约能执行10^8次简单操作
*/

/* ========== 15. 主函数模板 ========== */
void solve() {
    // 单个测试用例的解决方案
    
}

signed main() {  // 使用signed main避免宏定义冲突
    fast_io();
    
    int T = 1;
    // cin >> T;  // 多测试用例时取消注释
    
    while(T--) {
        solve();
    }
    
    return 0;
}

/* ========================================
   重要提醒和注意事项
   ======================================== 
   
1. 数据类型选择：
   - int: -2^31 ~ 2^31-1 (约-2e9 ~ 2e9)
   - long long: -2^63 ~ 2^63-1 (约-9e18 ~ 9e18)
   - 两个int相乘可能溢出，需要转换为long long

2. 模运算注意事项：
   - (a + b) % MOD = ((a % MOD) + (b % MOD)) % MOD
   - (a - b) % MOD = ((a % MOD) - (b % MOD) + MOD) % MOD
   - (a * b) % MOD = ((a % MOD) * (b % MOD)) % MOD

3. 浮点数比较：
   - 不要直接用 == 比较浮点数
   - 使用 abs(a - b) < EPS

4. 边界条件：
   - 数组越界
   - 空数组/字符串
   - n = 1 的特殊情况
   - 负数输入

5. 常见错误：
   - 忘记初始化
   - 循环变量类型不匹配
   - 递归没有返回值
   - 除零错误

6. 调试技巧：
   - 使用调试宏输出变量值
   - 检查中间结果是否合理
   - 构造小数据手动验证
   - 注意特殊情况和边界

7. 代码习惯：
   - 变量命名有意义
   - 适当添加注释
   - 保持代码整洁
   - 避免复杂的嵌套

8. 竞赛策略：
   - 先过样例再提交
   - 简单题先做
   - 时间复杂度要合理
   - 特判特殊情况
   ======================================== */
```

###  知识体系完善

1. **命名空间组织** - 按功能模块划分，便于查找
2. **更多数学函数** - 逆元、组合数、扩展欧几里得
3. **完整的位运算技巧** - 包含各种实用操作
4. **输入输出优化** - 包含具体的读取技巧
5. **调试宏扩展** - 支持向量、pair等复杂类型

###  重要提醒

在文件末尾添加了详细的**注意事项**，包括：

- 数据类型选择指南
- 模运算正确写法
- 浮点数比较方法
- 常见错误和调试技巧
- 竞赛策略建议

## 排序

排序一般使用两类：

- 基于比较的排序，常用快排、sort（数组和vector）
- 桶排序（唯一的线性时间复杂度的排序）

不过要考虑数字的值域和个数

### 冒泡排序

优化：加入bool值进行判断，如果一轮冒泡中没有进行换序，则终止排序

```c++
void BubbleSort(vector<int>&arr)//冒泡排序
{
    size_t length=arr.size();
    for(size_t i=length-1;i>0;i--)
    {
        bool jud=false;
        for(size_t j=0;j<i;j++)
        {
            if(arr[j]>arr[j+1])
            {
                jud=true;
                int tem=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=tem;
            }
        }
        if(!jud)
        {
            return;
        }
    }
}
```



### 选择排序

优化：每次排序时同时抽出最大和最小值，分别放在两侧，使循环次数减半

```c++
void selectsort(vector<int>&arr)//选择排序
{
    size_t length=arr.size();
    for(size_t i=length-1;i>0;i--)
    {
        int tem=0;
        for(size_t j=0;j<=i;j++)
        {
            if(arr[j]>arr[tem])
            {
                tem=j;
            }
        }
        int temnum;
        temnum=arr[i];
        arr[i]=arr[tem];
        arr[tem]=temnum;
    }
}
```

### 桶排序

桶排序的核心思想是：

1. 设定一个定量的数组当作空桶子
2. 遍历序列，将每个元素放到对应的桶中
3. 对每个不为空的桶进行排序
4. 从不为空的桶里把元素再放回原来的序列中

算法步骤

1. **确定桶的数量**：通常根据数据范围和数据量来决定
2. **初始化桶**：创建足够数量的空桶
3. **分配元素**：遍历原数组，将元素分配到对应的桶中
4. **桶内排序**：对每个非空桶内的元素进行排序（通常使用插入排序或其他排序算法）
5. **合并结果**：按桶的顺序将所有元素合并回原数组

```c++
#include <bits/stdc++.h>
using namespace std;

const int N=0x3f3f3f3f;
int bucket[N];//bucket[i]表示第i个桶内有几个，即数字i出现的个数、
//数组在全局定义（栈空间），其元素默认为0
//若在主函数内定义，则在堆空间内，元素不会默认为0，需要memset初始化
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m;
    cin>>n>>m;
    int tem;
    for(int i=0;i<m;i++)
    {   
        cin>>tem;
        bucket[tem]++;
    }
    for(int i=0;i<=n;i++)
    {
        for(int j=0;j<bucket[i];j++)
        {
            cout<<i<<" ";
        }
    }
    return 0;
}
```

桶排序特别适用于以下情况：

1. **数据分布均匀**：当输入数据在一个范围内均匀分布时效果最好
2. **数据范围已知**：需要事先知道数据的大致范围
3. **大数据集**：对于大规模数据，可以利用并行处理优势

优缺点

**优点：**

- 当数据**分布均匀**时，时间复杂度接近线性
- 可以并行化处理
- 稳定排序

**缺点：**

- 需要额外的存储空间
- 对数据分布敏感，分布不均匀时性能退化
- **需要事先知道数据范围**

桶排序在特定场景下非常高效，特别是在**数据分布相对均匀且范围已知**的情况下，是一个很好的排序选择。

### 归并排序（分治法）

归并排序是基于**分治法**的稳定（相等元素顺序不变）排序算法

#### 算法性能

时间复杂度为O(nlogn)
空间复杂度为O(N)(归并排序需要一个与原数组相同长度的数组做辅助来排序)
适合大数据量排序

#### **思路**
归并排序分为“分”和”治”两个基本操作：**分**即将原数组划分为两个子数组的过程，**治**即将两个有序数组合并成一个更大的有序数组。

1. 将待排序的线性表不断地切分成若干个子表，直至每个子表只包含一个元素，这时，可以认为只包含一个元素的子表是有序表；
2. 将子表两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直至最后只剩下一个字表，这个字表就是排好序的线性表。

![img](https://i-blog.csdnimg.cn/blog_migrate/79510ba165786116c3a394cf6c4ee6f9.png)

这种结构很像一颗完全二叉树，分阶段可以理解为递归拆分子序列的过程，递归的深度为$log_2n$。

**如何合并有序序列？**

通过三个指针（下标）控制子列1、子列2以及目标序列

#### 实现方法

1. 递归实现（经典方法）
2. 迭代实现（自底向上）
3. 简化递归实现

```c++
#include<bits/stdc++.h>
using namespace std;

// 合并两个已排序的子数组
void merge(vector<int>& arr, int left, int mid, int right) {
    // 创建临时数组
    vector<int> temp(right - left + 1);
    
    int i = left;    // 左子数组起始索引
    int j = mid + 1; // 右子数组起始索引
    int k = 0;       // 临时数组索引
    
    // 比较合并两个子数组
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {  // 使用<=保证稳定性
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    
    // 复制剩余元素
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    
    // 将结果复制回原数组
    for (i = 0; i < temp.size(); i++) {
        arr[left + i] = temp[i];
    }
}

// 递归归并排序
void mergeSortRecursive(vector<int>& arr, int left, int right) {
    if (left >= right) return;  // 基础情况
    
    int mid = left + (right - left) / 2;  // 避免溢出
    
    // 递归排序左右两部分
    mergeSortRecursive(arr, left, mid);
    mergeSortRecursive(arr, mid + 1, right);
    
    // 合并已排序的部分
    merge(arr, left, mid, right);
}

// 递归版本包装函数
void mergeSortRecursive(vector<int>& arr) {
    if (arr.size() > 1) {
        mergeSortRecursive(arr, 0, arr.size() - 1);
    }
}
// 迭代归并排序（自底向上）
void mergeSortIterative(vector<int>& arr) {
    int n = arr.size();
    if (n <= 1) return;
    
    // 从小子数组开始，逐渐增大合并范围
    for (int size = 1; size < n; size *= 2) {
        // 对每个大小为size的相邻子数组进行合并
        for (int left = 0; left < n - size; left += 2 * size) {
            int mid = left + size - 1;
            int right = min(left + 2 * size - 1, n - 1);
            
            merge(arr, left, mid, right);  // 复用上面的merge函数
        }
    }
}
// 简化合并函数
vector<int> mergeSimple(const vector<int>& left, const vector<int>& right) {
    vector<int> result;
    int i = 0, j = 0;
    
    while (i < left.size() && j < right.size()) {
        if (left[i] <= right[j]) {
            result.push_back(left[i++]);
        } else {
            result.push_back(right[j++]);
        }
    }
    
    // 添加剩余元素
    while (i < left.size()) result.push_back(left[i++]);
    while (j < right.size()) result.push_back(right[j++]);
    
    return result;
}

// 简化递归排序
vector<int> mergeSortSimple(vector<int> arr) {
    if (arr.size() <= 1) return arr;
    
    int mid = arr.size() / 2;
    vector<int> left(arr.begin(), arr.begin() + mid);
    vector<int> right(arr.begin() + mid, arr.end());
    
    // 递归排序并合并
    return mergeSimple(mergeSortSimple(left), mergeSortSimple(right));
}
// 打印数组工具函数
void printArray(const vector<int>& arr, const string& title) {
    cout << title << ": ";
    for (int num : arr) cout << num << " ";
    cout << endl;
}

// 性能测试函数
void performanceTest() {
    cout << "\n=== 性能测试 ===" << endl;
    
    // 创建测试数据（1000个逆序数）
    vector<int> testData;
    for (int i = 1000; i > 0; i--) {
        testData.push_back(i);
    }
    
    // 测试递归版本
    vector<int> arr1 = testData;
    auto start = chrono::high_resolution_clock::now();
    mergeSortRecursive(arr1);
    auto end = chrono::high_resolution_clock::now();
    auto time1 = chrono::duration_cast<chrono::microseconds>(end - start);
    
    // 测试迭代版本
    vector<int> arr2 = testData;
    start = chrono::high_resolution_clock::now();
    mergeSortIterative(arr2);
    end = chrono::high_resolution_clock::now();
    auto time2 = chrono::duration_cast<chrono::microseconds>(end - start);
    
    cout << "递归版本: " << time1.count() << " 微秒" << endl;
    cout << "迭代版本: " << time2.count() << " 微秒" << endl;
}

// 主函数演示
int main() {
    vector<int> data = {64, 34, 25, 12, 22, 11, 90, 5, 77, 30};
    
    cout << "=== 归并排序演示 ===" << endl;
    printArray(data, "原始数组");
    
    // 测试三种方法
    vector<int> arr1 = data;
    mergeSortRecursive(arr1);
    printArray(arr1, "递归排序");
    
    vector<int> arr2 = data;
    mergeSortIterative(arr2);
    printArray(arr2, "迭代排序");
    
    vector<int> arr3 = mergeSortSimple(data);
    printArray(arr3, "简化排序");
    
    // 性能测试
    performanceTest();
    
    return 0;
}
```

#### 用途

归并排序是各种“**分治统计**”问题的基石，除了**逆序对，还能解决偏序、区间第 k 大/小**等复杂问题。

## gcd&lcm（唯一分解部分未学习-涉及数论知识）

```c++
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
ll gcd(ll a,ll b)
{
    return b==0?a:gcd(b,a%b);
}
int main()
{
    ll a,b;
    cin>>a>>b;
    cout<<gcd(a,b)<<" "<<a/gcd(a,b)*b;//先除以gcd(a,b)保证不超范围
    return 0;
}
```

if(a>=b),gcd(a,b)=gcd(a-b,b)
gcd(a,0)=a
a\*b=gcd(a,b)\*lcm(a,b)

```c++
#include <bits/stdc++.h>
using namespace std;

// 基础gcd函数（欧几里得算法）
long long gcd(long long a, long long b) {
    return b == 0 ? a : gcd(b, a % b);
}

// 基础lcm函数
long long lcm(long long a, long long b) {
    return a / gcd(a, b) * b;  // 先除再乘，防止溢出
}

// 多个数的gcd
long long gcd_multiple(vector<long long>& nums) {
    long long result = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        result = gcd(result, nums[i]);
        if (result == 1) break;  // 早期终止优化
    }
    return result;
}

// 多个数的lcm
long long lcm_multiple(vector<long long>& nums) {
    long long result = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        result = lcm(result, nums[i]);
        // 可以加入溢出检查
        if (result > 1e18) return -1; // 表示溢出
    }
    return result;
}

// 扩展欧几里得算法（求解 ax + by = gcd(a,b)）
long long exgcd(long long a, long long b, long long& x, long long& y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    long long x1, y1;
    long long d = exgcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - (a / b) * y1;
    return d;
}

// 简单的质因数分解（仅在需要时使用）
map<long long, int> getPrimeFactors(long long n) {
    map<long long, int> factors;
    
    // 处理2
    while (n % 2 == 0) {
        factors[2]++;
        n /= 2;
    }
    
    // 处理奇数因子
    for (long long i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            factors[i]++;
            n /= i;
        }
    }
    
    // 如果n是大于2的质数
    if (n > 2) factors[n] = 1;
    
    return factors;
}

// 实际竞赛中常用的组合
int main() {
    // 例子1：多个数的gcd和lcm
    vector<long long> nums = {12, 18, 24, 30};
    
    cout << "Numbers: ";
    for (long long x : nums) cout << x << " ";
    cout << endl;
    
    cout << "GCD: " << gcd_multiple(nums) << endl;
    cout << "LCM: " << lcm_multiple(nums) << endl;
    
    // 例子2：两两配对的所有gcd
    cout << "\nPairwise GCDs:" << endl;
    for (int i = 0; i < nums.size(); i++) {
        for (int j = i + 1; j < nums.size(); j++) {
            cout << "gcd(" << nums[i] << ", " << nums[j] << ") = " 
                 << gcd(nums[i], nums[j]) << endl;
        }
    }
    
    // 例子3：检查是否两两互质
    bool all_coprime = true;
    for (int i = 0; i < nums.size() && all_coprime; i++) {
        for (int j = i + 1; j < nums.size(); j++) {
            if (gcd(nums[i], nums[j]) != 1) {
                all_coprime = false;
                break;
            }
        }
    }
    cout << "\nAre all numbers pairwise coprime? " << (all_coprime ? "Yes" : "No") << endl;
    
    return 0;
}
```

## 欧拉函数（质数）

```c++
int euler_phi(int n) {
    int result = n;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            while (n % i == 0) n /= i;
            result -= result / i;  // result = result * (1 - 1/i)
        }
    }
    if (n > 1) result -= result / n;
    return result;
}
```

**欧拉函数φ(n)**：小于等于n且与n互质的正整数个数

## pair数组的使用

普通的`vector<pair<int,int>>`就足够了：

- `pair`可以很好地存储价格和质量的配对
- 排序操作对pair也很高效（先按第一个元素排序）
- 不需要额外的查找操作，所以set/map的优势用不上

```c++
const int N=1e6+6;
vector<pair<int,int>>Arr(N);//注意是()而非[]
//存储查找元素
Arr[i].first;
Arr[i].second;
//排序
sort(Arr.begin(),Arr.end())//sort(Arr.begin(),Arr.begin()+n);
//默认sort排序按照pair数组的第一个数值进行排序，第一个数值相同时再按照第二个数值排序，从小到大
//也可以使用lambda表达式或者自定义比较函数（bool cmp（））
/ 自定义排序（按 second 降序）
    sort(vec.begin(), vec.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
        return a.second > b.second;
    });
```



## lambda表达式(详见csdn)

常用于比较（排序）

Lambda表达式是现代C++在C ++ 11和更高版本中的一个新的[语法糖](https://so.csdn.net/so/search?q=语法糖&spm=1001.2101.3001.7020) ，在C++11、C++14、C++17和C++20中Lambda表达的内容还在不断更新。 lambda表达式（也称为lambda函数）是**在调用或作为函数参数传递的位置处定义匿名函数对象的便捷方法**。通常，lambda用于**封装传递给算法或异步方法的几行代码** 。

```c++
#include <algorithm>
#include <cmath>

void abssort(float* x, unsigned n) {
    std::sort(x, x + n,
        // Lambda expression begins
        [](float a, float b) {
            return (std::abs(a) < std::abs(b));
        } // end of lambda expression
    );
}

```

在上面的实例中`std::sort`函数第三个参数应该是**传递一个排序规则的函数**，但是这个实例中直接将排序函数的实现写在应该传递函数的位置，**省去了定义排序函数的过程**，对于这种**不需要复用，且短小的函数**，**直接传递函数体**可以增加代码的可读性。

![img](https://i-blog.csdnimg.cn/blog_migrate/66eb37693756682da8e76988b1c7f66c.png)

1. 捕获列表。在C++规范中也称为Lambda导入器， 捕获列表总是出现在Lambda函数的开始处。实际上，**`[]`是Lambda引出符**。编译器根据该引出符判断接下来的代码是否是Lambda函数，捕获列表能够**捕捉上下文中的变量以供Lambda函数使用**。
2. 参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略。
3. 可变规格。`mutable`修饰符， 默认情况下Lambda函数总是一个`const`函数，`mutable`可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。
4. 异常说明。用于Lamdba表达式内部函数抛出异常。
5. 返回类型。 追踪返回类型形式声明函数的返回类型。我们可以在不需要返回值的时候也可以连同符号”->”一起省略。此外，**在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。**
6. lambda函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。

### 适用场景

Lambda表达式应用于STL算法库

**for_each**

```c++
int a[4] = {11, 2, 33, 4};
sort(a, a+4, [=](int x, int y) -> bool { return x%10 < y%10; } );
for_each(a, a+4, [=](int x) { cout << x << " ";} );
```

**find_if**

```c++
int x = 5;
int y = 10;
deque<int> coll = { 1, 3, 19, 5, 13, 7, 11, 2, 17 };
auto pos = find_if(coll.cbegin(), coll.cend(), [=](int i) {                 
    return i > x && i < y;
});

```

**remove_if**

```c++
std::vector<int> vec_data = {1, 2, 3, 4, 5, 6, 7, 8, 9};
int x = 5;
vec_data.erase(std::remove_if(vec.date.begin(), vec_data.end(), [](int i) { 
    return n < x;}), vec_data.end());

std::for_each(vec.date.begin(), vec_data.end(), [](int i) { 
    std::cout << i << std::endl;});

```

短小不需要复用的函数场景

`sort`函数

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main(void)
{
    int data[6] = { 3, 4, 12, 2, 1, 6 };
    vector<int> testdata;
    testdata.insert(testdata.begin(), data, data + 6);

    // 对于比较大小的逻辑，使用lamdba不需要在重新定义一个函数
    sort(testdata.begin(), testdata.end(), [](int a, int b){ 
        return a > b; });

    return 0;
}

```

## 快速幂

快速幂算法基于二进制分解的思想，利用以下性质：

- 如果指数n是偶数：`a^n = (a^(n/2))^2`
- 如果指数n是奇数：`a^n = a * a^(n-1)`

时间复杂度：O(log n)
### 递归实现

```c++
long long fastPow(long long base, long long exp, long long mod) {
    if (exp == 0) return 1;
    long long half = fastPow(base, exp / 2, mod);
    half = (half * half) % mod;
    if (exp % 2 == 1) {
        half = (half * base) % mod;
    }
    return half;
}
```

### 迭代实现

```c++
long long fastPow(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1) {  // 如果exp是奇数
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp >>= 1;  // exp /= 2
    }
    return result;
}
```

###  应用场景

- 计算大数幂取模
- RSA加密算法
- 费马小定理验证
- 计算逆元：`a^(p-2) mod p`（当p为质数时）

## 矩阵快速幂

矩阵快速幂是快速幂在矩阵运算上的扩展，用于快速计算矩阵的幂次。

### 核心思想：

- 将矩阵乘法作为"乘法"操作
- 将单位矩阵作为"1"
- 应用快速幂的二进制分解思想

```c++
#include <bits/stdc++.h>
using namespace std;
using matrix=vector<vector<long long>>;
long long modnum=1e9+7;
int N;
matrix multiply(matrix &A,matrix& B)
{
    matrix res(N+1,vector<long long>(N+1,0));
    for(int i=1;i<=N;i++)
    {
        for(int j=1;j<=N;j++)
        {
            for(int k=1;k<=N;k++)
            {
                
                res[i][j]+=1ll*A[i][k]*B[k][j]%modnum;
                res[i][j]%=modnum;
            }
        }
    }
    return res;
}
matrix quickpow(matrix A,long long exp)
{
    matrix res(N+1,vector<long long>(N+1,0));
    for(int i=1;i<=N;i++)
    {
        res[i][i]=1;
    }
    while(exp)
    {
        if(exp%2==1)
        {
            res=multiply(res,A);
        }
    A=multiply(A,A);
    exp/=2;
    }
    return res;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>N;
    long long exp;
    cin>>exp;
    matrix A(N+1,vector<long long>(N+1));
    for(int i=1;i<=N;i++)
    {
        for(int j=1;j<=N;j++)
        {
            cin>>A[i][j];
        }
    }
    matrix ans=quickpow(A,exp);
    for(int i=1;i<=N;i++)
    {
        for(int j=1;j<=N;j++)
        {
            cout<<ans[i][j]<<(j == N ? "" : " ");
        }
        cout<<endl;
    }
    return 0;
}
```

### 经典应用

#### 斐波那契

```c++
// F(n) = F(n-1) + F(n-2)
// [F(n), F(n-1)] = [F(n-1), F(n-2)] * [[1,1],[1,0]]

long long fibonacci(long long n) {
    if (n <= 1) return n;
    
    Matrix base(2);
    base.mat[0][0] = 1; base.mat[0][1] = 1;
    base.mat[1][0] = 1; base.mat[1][1] = 0;
    
    Matrix result = matrixPow(base, n - 1);
    
    // [F(n), F(n-1)] = [F(1), F(0)] * base^(n-1)
    // F(n) = 1 * result[0][0] + 0 * result[1][0]
    return result.mat[0][0];
}
```

#### 线性递推关系

对于递推关系：`f(n) = a1*f(n-1) + a2*f(n-2) + ... + ak*f(n-k)`
构造转移矩阵

```
[f(n)]     [a1 a2 a3 ... ak] [f(n-1)]
[f(n-1)]   [1  0  0  ... 0 ] [f(n-2)]
[f(n-2)] = [0  1  0  ... 0 ] [f(n-3)]
[...]      [...       ... ] [...]
[f(n-k+1)] [0  0  0  ... 0 ] [f(n-k)]
```

#### 图论中的路径计算

计算图中从点u到点v长度为k的路径数量：

- 构造邻接矩阵A
- A^k\[u][v]即为答案

```c++
// 计算图中长度为k的路径数
Matrix adjacencyMatrix(int n, vector<pair<int,int>>& edges) {
    Matrix adj(n);
    for (auto& edge : edges) {
        adj.mat[edge.first][edge.second] = 1;
        // 如果是无向图，还需要：adj.mat[edge.second][edge.first] = 1;
    }
    return adj;
}

long long countPaths(Matrix adj, int u, int v, long long k) {
    Matrix result = matrixPow(adj, k);
    return result.mat[u][v];
}
```

## 树状数组

引入：树状数组求逆序对
线性数组->树状数组

## 高精度

cpp中，long long都无法表示所需数字的时候，可以选择使用高精度（一般数字极大）

```c++
#include<bits/stdc++.h>
using namespace std;

// 去除前导零
string removeLeadingZeros(string s) {
    int pos = 0;
    while (pos < s.length() - 1 && s[pos] == '0') pos++;
    return s.substr(pos);
}

// 比较两个高精度数的绝对值大小
// 返回1表示a>b，0表示a=b，-1表示a<b
int compareAbs(string a, string b) {
    if (a.length() > b.length()) return 1;
    if (a.length() < b.length()) return -1;
    return a.compare(b);
}

// 高精度加法（两个正数）
string addPositive(string a, string b) {
    string ans = "";
    int i = a.length() - 1;
    int j = b.length() - 1;
    int carry = 0;
    
    while (i >= 0 || j >= 0 || carry) {
        int sum = carry;
        if (i >= 0) sum += a[i--] - '0';
        if (j >= 0) sum += b[j--] - '0';
        
        ans = char(sum % 10 + '0') + ans;
        carry = sum / 10;
    }
    return ans;
}

// 高精度减法（两个正数绝对值，保证a >= b）
string subtractAbs(string a, string b) {
    string ans = "";
    int borrow = 0;
    int i = a.length() - 1;
    int j = b.length() - 1;
    
    while (i >= 0) {
        int sub = a[i] - '0' - borrow;
        if (j >= 0) sub -= b[j--] - '0';
        
        if (sub < 0) {
            sub += 10;
            borrow = 1;
        } else {
            borrow = 0;
        }
        
        ans = char(sub + '0') + ans;
        i--;
    }
    
    return removeLeadingZeros(ans);
}

// 完整的高精度加法（处理正负号）
string add(string a, string b) {
    bool negA = a[0] == '-';
    bool negB = b[0] == '-';
    
    if (negA) a = a.substr(1);
    if (negB) b = b.substr(1);
    
    if (negA == negB) {
        // 同号相加
        string result = addPositive(a, b);
        return negA ? "-" + result : result;
    } else {
        // 异号相减
        int cmp = compareAbs(a, b);
        if (cmp == 0) return "0";
        
        string result;
        bool resultNeg;
        
        if (cmp > 0) {
            result = subtractAbs(a, b);
            resultNeg = negA;
        } else {
            result = subtractAbs(b, a);
            resultNeg = negB;
        }
        
        return resultNeg ? "-" + result : result;
    }
}

// 完整的高精度减法（a - b）
string subtract(string a, string b) {
    // a - b = a + (-b)
    if (b[0] == '-') {
        b = b.substr(1);  // 去掉负号
    } else {
        b = "-" + b;      // 加上负号
    }
    return add(a, b);
}

// 高精度乘以单个数字
string multiplyDigit(string a, int digit) {
    if (digit == 0) return "0";
    
    bool neg = a[0] == '-';
    if (neg) a = a.substr(1);
    
    string ans = "";
    int carry = 0;
    
    for (int i = a.length() - 1; i >= 0; i--) {
        int prod = (a[i] - '0') * digit + carry;
        ans = char(prod % 10 + '0') + ans;
        carry = prod / 10;
    }
    
    while (carry) {
        ans = char(carry % 10 + '0') + ans;
        carry /= 10;
    }
    
    return neg ? "-" + ans : ans;
}

// 高精度乘法
string multiply(string a, string b) {
    if (a == "0" || b == "0") return "0";
    
    bool negA = a[0] == '-';
    bool negB = b[0] == '-';
    
    if (negA) a = a.substr(1);
    if (negB) b = b.substr(1);
    
    string ans = "0";
    string zeros = "";
    
    for (int i = b.length() - 1; i >= 0; i--) {
        string temp = multiplyDigit(a, b[i] - '0') + zeros;
        ans = add(ans, temp);
        zeros += "0";
    }
    
    bool resultNeg = negA ^ negB;  // 异号为负
    return resultNeg ? "-" + ans : ans;
}

// 高精度除以单个数字
string divideDigit(string a, int digit, int &remainder) {
    if (digit == 0) return "ERROR";  // 除零错误
    
    bool neg = a[0] == '-';
    if (neg) a = a.substr(1);
    
    string ans = "";
    remainder = 0;
    
    for (int i = 0; i < a.length(); i++) {
        remainder = remainder * 10 + (a[i] - '0');
        ans += char(remainder / digit + '0');
        remainder %= digit;
    }
    
    ans = removeLeadingZeros(ans);
    return neg ? "-" + ans : ans;
}

// 高精度阶乘
string factorial(int n) {
    if (n < 0) return "ERROR";
    string ans = "1";
    for (int i = 2; i <= n; i++) {
        ans = multiplyDigit(ans, i);
    }
    return ans;
}

// 高精度幂运算 a^b（b为非负整数）
string power(string a, int b) {
    if (b < 0) return "ERROR";
    if (b == 0) return "1";
    if (a == "0") return "0";
    
    string ans = "1";
    string base = a;
    
    while (b > 0) {
        if (b & 1) ans = multiply(ans, base);
        base = multiply(base, base);
        b >>= 1;
    }
    return ans;
}

// 主函数示例
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    string a, b;
    cin >> a >> b;
    
    cout << "a + b = " << add(a, b) << endl;
    cout << "a - b = " << subtract(a, b) << endl;
    cout << "a * b = " << multiply(a, b) << endl;
    
    return 0;
}

/*
完整性检查清单：

✓ 正负号处理：所有运算都支持负数
✓ 前导零处理：统一使用removeLeadingZeros函数
✓ 边界情况：0, 空字符串, 单个数字等
✓ 溢出处理：使用string避免整数溢出
✓ 错误处理：除零等异常情况

核心注意事项：
1. 负号处理：统一在最外层处理符号，内层只处理绝对值
2. 比较函数：先比较长度，再字典序比较
3. 进位/借位：用%和/比if-else更简洁
4. 循环边界：while(i>=0 || j>=0 || carry)确保完整处理
5. 特殊值：0的各种表示形式需要统一处理

常见bug：
- 忘记去前导零：导致"000123"等错误结果
- 符号处理不当：-0, --5等错误
- 边界条件遗漏：空字符串、单字符等
- 借位处理错误：减法时忘记处理连续借位
- 除零未检查：可能导致程序崩溃

性能优化建议：
- 乘法可用Karatsuba算法优化到O(n^1.585)
- 除法可用二分+乘法实现
- FFT可将乘法优化到O(nlogn)但实现复杂
*/
```

