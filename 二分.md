# 二分算法完整总结

## 二分算法核心思想

二分算法基于"分治"思想，通过不断将搜索区间一分为二，快速缩小搜索范围。时间复杂度为 O(log n)。

**二分的基础的用法是在单调序列或单调函数中查找**。因此当问题的答案具有单调性时，就可以通过二分把求解转化为判定。

## 基本模板

**整数域上的二分，需要考虑终止边界、左右区间取舍时的开闭情况，避免漏掉答案或造成死循环。**

### 整数二分 - 查找目标值

```cpp
int binary_search(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // 防止溢出
        
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;  // 未找到
}
```

### 整数二分 - 查找边界

```cpp
// 查找第一个 >= target 的位置（左边界）
int lower_bound(vector<int>& nums, int target) {
    int left = 0, right = nums.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

// 查找第一个 > target 的位置（右边界）
int upper_bound(vector<int>& nums, int target) {
    int left = 0, right = nums.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
```

**实数域上的二分，需要注意精度问题。**

### 实数二分

```cpp
double binary_search_real(double left, double right) {
    while (right - left > 1e-9) {  // 精度控制
        double mid = (left + right) / 2.0;
        
        if (check(mid)) {  // 判定函数
            right = mid;
        } else {
            left = mid;
        }
    }
    return left;
}
```

### 万能二分模板

```cpp
// 查找满足条件的最小值
int binary_search_min(int left, int right, function<bool(int)> check) {
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (check(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}

// 查找满足条件的最大值
int binary_search_max(int left, int right, function<bool(int)> check) {
    while (left < right) {
        int mid = left + (right - left + 1) / 2;  // 注意 +1
        
        if (check(mid)) {
            left = mid;
        } else {
            right = mid - 1;
        }
    }
    return left;
}
```

## 常见题型分类

### 基础查找类

- **经典二分查找**：在有序数组中查找目标值
- **查找插入位置**：找到目标值应该插入的位置
- **查找重复元素边界**：找到重复元素的第一个和最后一个位置
- **旋转数组查找**：在旋转排序数组中查找元素

```cpp
// 示例：旋转数组查找
int search_rotated(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] == target) return mid;
        
        if (nums[left] <= nums[mid]) {  // 左半部分有序
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {  // 右半部分有序
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return -1;
}
```

### 答案二分类（最优化问题）

通过二分答案，将最优化问题转化为判定问题。

**经典题目**：

- **分割数组的最大值**：将数组分成m个子数组，使最大子数组和最小
- **运输能力**：在D天内运完所有货物的最小运载能力
- **供暖器问题**：所有房屋都被供暖的最小半径

```cpp
// 示例：运输能力问题
class Solution {
private:
    bool canShip(vector<int>& weights, int D, int capacity) {
        int days = 1, currentWeight = 0;
        
        for (int weight : weights) {
            if (currentWeight + weight > capacity) {
                days++;
                currentWeight = weight;
                if (days > D) return false;
            } else {
                currentWeight += weight;
            }
        }
        return true;
    }
    
public:
    int shipWithinDays(vector<int>& weights, int D) {
        int left = *max_element(weights.begin(), weights.end());
        int right = accumulate(weights.begin(), weights.end(), 0);
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (canShip(weights, D, mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

### 实数二分类

主要用于求解方程、优化问题等。

**经典题目**：

- **三次方程求根**：求三次方程的实数解
- **最小化最大值**：如最小化加油站距离
- **物理问题**：如自由落体时间计算

```cpp
// 示例：求平方根
double sqrt_binary(double x) {
    if (x == 0) return 0;
    
    double left = 0, right = max(1.0, x);
    
    while (right - left > 1e-9) {
        double mid = (left + right) / 2.0;
        
        if (mid * mid <= x) {
            left = mid;
        } else {
            right = mid;
        }
    }
    return left;
}
```

### 二维二分/矩阵二分

- **二维矩阵查找**：在行列都有序的矩阵中查找
- **第K小元素**：在有序矩阵中找第K小的元素

```cpp
// 示例：有序矩阵中第K小元素
int kthSmallest(vector<vector<int>>& matrix, int k) {
    int n = matrix.size();
    int left = matrix[0][0], right = matrix[n-1][n-1];
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        int count = 0;
        
        // 统计 <= mid 的元素个数
        for (int i = 0; i < n; i++) {
            count += upper_bound(matrix[i].begin(), matrix[i].end(), mid) 
                     - matrix[i].begin();
        }
        
        if (count < k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
```

## 关键技巧总结

### 边界处理

```cpp
// 查找左边界时：left < right，right = mid
// 查找右边界时：left < right，left = mid + 1
// 注意right边界时需要 mid = left + (right - left + 1) / 2
```

### 防止死循环

- 查找最大值时：`mid = left + (right - left + 1) / 2`
- 查找最小值时：`mid = left + (right - left) / 2`

### 精度控制

- 整数二分：注意边界条件
- 实数二分：控制精度 `1e-9` 通常足够
- 避免浮点误差

### check函数设计

答案二分的核心是设计正确的check函数：

- 明确判定条件
- 确保单调性
- 边界情况处理

## 常见错误及避免方法

1. **死循环**：mid计算方式错误
2. **边界错误**：left、right初始值或更新方式错误
3. **精度问题**：实数二分精度不够
4. **单调性判断错误**：check函数逻辑有误
5. **溢出问题**：使用 `left + (right - left) / 2` 避免

## 练习建议

1. **基础练习**：LeetCode 704, 35, 34, 33
2. **答案二分**：LeetCode 410, 1011, 1283, 875
3. **实数二分**：各OJ的数学题
4. **综合应用**：结合贪心、动态规划等算法

掌握这些模板和技巧，就能应对绝大多数二分算法题目！